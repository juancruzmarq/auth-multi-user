generator client {
  provider = "prisma-client"
  output =  "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  PENDING
}

enum MailStatus {
  PENDING
  SENDING
  SENT
  FAILED
}

enum MailType {
  WELCOME_EMAIL
  PASSWORD_RESET
  VERIFY_EMAIL
  NOTIFICATION
}

enum AuthProvider {
  EMAIL
  GOOGLE
}

enum TokenPurpose {
  EMAIL_VERIFICATION
  PASSWORD_RESET
}

// -------------------------
// Usuario
// -------------------------
model User {
  id_user           String       @id @default(cuid())
  email             String       @unique @db.Citext      // requiere EXTENSION citext
  email_verified    Boolean      @default(false)
  email_verified_at DateTime?
  status            UserStatus   @default(PENDING)

  // Perfil
  name          String?
  surname       String?
  display_name  String?
  photo_url     String?
  phone_number  String?

  // Relaciones
  credential    Credential?
  accounts      Account[]
  sessions      Session[]
  audits        LoginAudit[]
  outbox        MailOutbox[]
  verificationTokens VerificationToken[]
  resetTokens   PasswordResetToken[]

  created_at    DateTime     @default(now())
  updated_at    DateTime     @updatedAt

  @@map("user")
  @@index([status, created_at])
}

// -------------------------
// Credenciales (email/password)
// -------------------------
model Credential {
  id_user       String   @id
  user          User     @relation(fields: [id_user], references: [id_user], onDelete: Cascade)
  password_hash String   // hash (bcrypt/argon2). Nunca guardar plano.
  algo          String   // "bcrypt-12" | "argon2id" etc.
  updated_at    DateTime @updatedAt
  @@map("credential")
}

// -------------------------
// Cuentas OAuth / Proveedor
// -------------------------
model Account {
  id_account    String       @id @default(cuid())
  id_user       String
  user          User         @relation(fields: [id_user], references: [id_user], onDelete: Cascade)

  provider      AuthProvider
  id_provider   String                         // sub externo (Google)
  email         String?       @db.Citext       // espejo del provider (no confiar ciegamente)
  access_token  String?                        // si se guarda, encriptar/TTL
  refresh_token String?                        // idem
  expires_at    DateTime?

  created_at    DateTime      @default(now())
  updated_at    DateTime      @updatedAt

  @@unique([provider, id_provider])
  @@index([id_user, provider])
  @@map("account")
}

// -------------------------
// Sesiones (Refresh tokens)
// -------------------------
model Session {
  id_session         String   @id @default(cuid())
  id_user            String
  user               User     @relation(fields: [id_user], references: [id_user], onDelete: Cascade)

  refresh_token_hash String   @unique         // guardar hash, no el token
  user_agent         String?
  ip                 String?
  revoked_at         DateTime?
  created_at         DateTime  @default(now())
  expires_at         DateTime
  updated_at         DateTime  @updatedAt

  @@index([id_user, expires_at])
  @@map("session")
}

// -------------------------
// Tokens de verificación
// -------------------------
model VerificationToken {
  id         String       @id @default(cuid())
  id_user    String
  user       User         @relation(fields: [id_user], references: [id_user], onDelete: Cascade)

  purpose    TokenPurpose
  token_hash String       @unique            // hash del token
  expires_at DateTime
  created_at DateTime     @default(now())

  @@unique([id_user, purpose])
  @@index([id_user, purpose, expires_at])
  @@map("verification_token")
}


// -------------------------
// Auditoría de login
// -------------------------
model LoginAudit {
  id_account  String   @id @default(cuid())
  id_user     String
  user        User     @relation(fields: [id_user], references: [id_user], onDelete: Cascade)

  event       String   // LOGIN_SUCCESS | LOGIN_FAILURE | LOGOUT | REFRESH_ROTATE
  ip          String?
  user_agent  String?
  created_at  DateTime @default(now())

  @@index([id_user, created_at])
  @@map("login_audit")
}

// -------------------------
// Outbox de emails
// -------------------------
model MailOutbox {
  id_mail_outbox String   @id @default(cuid())
  id_user        String?
  user           User?    @relation(fields: [id_user], references: [id_user], onDelete: SetNull)

  to             String
  subject        String
  payload        Json
  template      String?
  type           MailType @default(WELCOME_EMAIL)
  status         MailStatus @default(PENDING)
  retry          Int      @default(0)
  created_at     DateTime @default(now())
  sent_at        DateTime?
  last_error     String?

  @@unique([type, to, created_at]) // evitar duplicados exactos
  @@index([id_user, sent_at])
  @@map("mail_outbox")
}
